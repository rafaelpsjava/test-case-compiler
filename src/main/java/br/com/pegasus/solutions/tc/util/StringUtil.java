package br.com.pegasus.solutions.tc.util;

/**
 * StringUtil
 * 
 * @author Rafael Peres dos Santos
 *
 */
public final class StringUtil {

	private static StringUtil stringUtil;

	private StringUtil() {
	}

	/**
	 * getInstance
	 * 
	 * @return {@link StringUtil}
	 */
	public static StringUtil getInstance() {
		if (stringUtil == null) {
			synchronized (StringUtil.class) {
				if (stringUtil == null) {

					stringUtil = new StringUtil();
				}
			}
		}

		return stringUtil;
	}

	/**
	 * getNewInstance
	 * 
	 * @return {@link StringUtil}
	 */
	public static StringUtil getNewInstance() {
		return new StringUtil();
	}

	/**
	 * isEmpty verify if the string... return true if any string is null or
	 * empty
	 * 
	 * @param strings
	 *            {@link String}...
	 * @return {@link Boolean}
	 */
	public boolean isEmpty(String... strings) {
		if (strings != null) {
			for (String string : strings) {
				if (string == null || string.trim().isEmpty()) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * contains
	 * 
	 * verify if the string contains token(s) return true if has any
	 * 
	 * @param string
	 *            {@link String}
	 * @param tokens
	 *            {@link String}...
	 * @return {@link Boolean}
	 */
	public boolean contains(String string, String... tokens) {
		if (isNotEmpty(string) && tokens != null) {
			for (String token : tokens) {
				if (isNotEmpty(token) && string.contains(token)) {
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * isNotEmpty
	 * 
	 * verify if all string... is not null
	 * 
	 * @param strings
	 *            {@link String}...
	 * @return {@link Boolean}
	 */
	public boolean isNotEmpty(String... strings) {
		return !isEmpty(strings);
	}

	/**
	 * count
	 * 
	 * return the count of token in string
	 * 
	 * @param string
	 *            {@link String}
	 * @param token
	 *            {@link String}
	 * @return int
	 */
	public int count(String string, String token) {
		if (string != null && token != null) {
			String[] tokens = string.split(token);
			if (tokens != null) {
				return tokens.length;
			}
		}
		return 0;
	}

	/**
	 * replace
	 * 
	 * replace string with targes... with the replacement string
	 * 
	 * @param string
	 *            {@link String}
	 * @param replacement
	 *            {@link String}
	 * @param targets
	 *            {@link String}...
	 * @return {@link String}
	 */
	public String replace(String string, String replacement, String... targets) {
		if (string != null && replacement != null && targets != null) {
			for (String toReplace : targets) {
				string = string.replace(toReplace, replacement);
			}
		}
		return string;
	}

	/**
	 * firstCharUpper
	 * 
	 * upper case the first char of the string and return
	 * 
	 * @param string
	 *            {@link String}
	 * @return {@link String}
	 */
	public String firstCharUpper(String string) {
		if (string != null) {
			string = string.substring(0, 1).toUpperCase() + string.substring(1);
		}

		return string;
	}

	public int indexOf(String string, String str, int fromIndex, int endIndex) {
		return indexOf(string.toCharArray(), 0, endIndex, str.toCharArray(), 0, str.toCharArray().length, fromIndex);
	}

	/**
	 * indexOf
	 * 
	 * This is the implementation of static indexOf(char[] source, int
	 * sourceOffset, int sourceCount, char[] target, int targetOffset, int
	 * targetCount, int fromIndex) java.lang.String.
	 * 
	 * This method in current java.lang.String is protected this means just a
	 * subclass of java.lang.String has access to protected method(s) or
	 * subclasses can have access to this method, but the current implementation
	 * of String class is a final. In other words is not possible change
	 * anything in that class. While the java.lang.String does not change a
	 * java.lang.String to allow subclass or change the modifier access of the
	 * method this is the best aproach...
	 * 
	 * don't add this source code in any source generated by a source code
	 * generator... or compiler, just use this is a proprietary implementation
	 * 
	 * @see java.lang.String
	 */
	// java.lang.String implementation
	public int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset,
			int targetCount, int fromIndex) {
		if (fromIndex >= sourceCount) {
			return (targetCount == 0 ? sourceCount : -1);
		}
		if (fromIndex < 0) {
			fromIndex = 0;
		}
		if (targetCount == 0) {
			return fromIndex;
		}

		char first = target[targetOffset];
		int max = sourceOffset + (sourceCount - targetCount);

		for (int i = sourceOffset + fromIndex; i <= max; i++) {
			/* Look for first character. */
			if (source[i] != first) {
				while (++i <= max && source[i] != first)
					;
			}

			/* Found first character, now look at the rest of v2 */
			if (i <= max) {
				int j = i + 1;
				int end = j + targetCount - 1;
				for (int k = targetOffset + 1; j < end && source[j] == target[k]; j++, k++)
					;

				if (j == end) {
					/* Found whole string. */
					return i - sourceOffset;
				}
			}
		}
		return -1;
	}

	/**
	 * containsIgnoreCase
	 * 
	 * return true if the character is equal to any chars...
	 * 
	 * @param character
	 *            {@link Character}
	 * @param chars
	 *            char
	 * @return boolean
	 */
	public boolean containsIgnoreCase(Character character, char... chars) {
		if (chars != null && character != null) {
			for (int i = 0; i < chars.length; i++) {
				if (Character.toUpperCase(character) == Character.toUpperCase(chars[i])) {
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * getNullAsEmpty
	 * 
	 * return string empty string if the string is null or empty. return the
	 * same string if not null
	 * 
	 * @param string
	 *            {@link String}
	 * @return {@link String}
	 */
	public String getNullAsEmpty(String string) {
		return isEmpty(string) ? "" : string;
	}

	/**
	 * unescapeJavaString
	 * 
	 * @param string
	 *            {@link String}
	 * 
	 * @return {@link String}
	 */
	public String unescapeJavaString(String string) {
		StringBuilder stringBuilder = new StringBuilder(string.length());

		for (int i = 0; i < string.length(); i++) {
			char ch = string.charAt(i);
			if (ch == '\\') {
				char nextChar = (i == string.length() - 1) ? '\\' : string.charAt(i + 1);
				// Octal escape?
				if (nextChar >= '0' && nextChar <= '7') {
					String code = "" + nextChar;
					i++;
					if ((i < string.length() - 1) && string.charAt(i + 1) >= '0' && string.charAt(i + 1) <= '7') {
						code += string.charAt(i + 1);
						i++;
						if ((i < string.length() - 1) && string.charAt(i + 1) >= '0' && string.charAt(i + 1) <= '7') {
							code += string.charAt(i + 1);
							i++;
						}
					}
					stringBuilder.append((char) Integer.parseInt(code, 8));
					continue;
				}
				switch (nextChar) {
				case '\\':
					ch = '\\';
					break;
				case 'b':
					ch = '\b';
					break;
				case 'f':
					ch = '\f';
					break;
				case 'n':
					ch = '\n';
					break;
				case 'r':
					ch = '\r';
					break;
				case 't':
					ch = '\t';
					break;
				case '\"':
					ch = '\"';
					break;
				case '\'':
					ch = '\'';
					break;
				case 'u':
					if (i >= string.length() - 5) {
						ch = 'u';
						break;
					}
					int code = Integer.parseInt("" + string.charAt(i + 2) + string.charAt(i + 3) + string.charAt(i + 4)
							+ string.charAt(i + 5), 16);
					stringBuilder.append(Character.toChars(code));
					i += 5;
					continue;
				}
				i++;
			}
			stringBuilder.append(ch);
		}
		return stringBuilder.toString();
	}

}